# DO NOT EDIT this file. It is set up in such a way that if you make any edits,
# the test cases may change resulting in a broken local autograder.

# Imports
import numpy as np
import sys, os, pdb
from test_rnn import RNN_Test

# Append paths and run
sys.path.append('mytorch')
from gru_cell import *
from search import *

sys.path.append('hw3')
import mc
import hw3

isTesting = True

# DO NOT CHANGE -->
EPS = 1e-20
SEED = 2021
np.random.seed(SEED)

# Tests
def assertions(user_vals, expected_vals, test_type, test_name):
    if test_type == 'type':
        try:
            assert type(user_vals) == type(expected_vals)
        except Exception as e:
            print('Type error, your type doesnt match the expected type.')
            print('Wrong type for %s' % test_name)
            print('Your type:   ', type(user_vals))
            print('Expected type:', type(expected_vals))
            return False
    elif test_type == 'shape':
        try:
            assert user_vals.shape == expected_vals.shape
        except Exception as e:
            print('Shape error, your shapes doesnt match the expected shape.')
            print('Wrong shape for %s' % test_name)
            print('Your shape:    ', user_vals.shape)
            print('Expected shape:', expected_vals.shape)
            return False
    elif test_type == 'closeness':
        try:
            assert np.allclose(user_vals, expected_vals)
        except Exception as e:
            print('Closeness error, your values dont match the expected values.')
            print('Wrong values for %s' % test_name)
            print('Your values:    ', user_vals)
            print('Expected values:', expected_vals)
            return False
    return True

############################################################################################
################################   Section 2 - MCQ    ######################################
############################################################################################

def test_mutiple_choice():
    scores = [0, 0, 0, 0]

    ref = ['b', 'b', 'b', 'a']
    ans_1 = mc.question_1()
    ans_2 = mc.question_2()
    ans_3 = mc.question_3()
    ans_4 = mc.question_4()
    ans = [ans_1, ans_2, ans_3, ans_4]

    for i in range(len(ref)):
        if ref[i] == ans[i]:
            scores[i] = 1

    return scores


############################################################################################
################################   Section 3 - GRU    ######################################
############################################################################################
def gru_cell_forward(cur_input, cur_result):
    # Get cur inputs
    input_dim = cur_input[0]
    hidden_dim = cur_input[1]
    seq_len = cur_input[2]

    data = np.random.randn(seq_len, input_dim)
    hidden = np.random.randn(hidden_dim)

    user_gru_cell = GRU_Cell(input_dim, hidden_dim)
    user_result = user_gru_cell.forward(data[0], hidden)

    if not assertions(user_result, cur_result, 'type', 'h_t'): return False
    if not assertions(user_result, cur_result, 'shape', 'h_t'): return False
    if not assertions(user_result, cur_result, 'closeness', 'h_t'): return False

    return True

def test_gru_forward():
    inputs = [[100, 150, 10], [90, 140, 8]]
    expected_results = np.load(os.path.join('autograder', 'hw3_autograder',
                               'data', 'gru_forward.npy'), allow_pickle = True)
    n = 2
    for i in range(2):
        cur_result = expected_results[i]
        cur_input = inputs[i]
        result = gru_cell_forward(cur_input, cur_result)
        if result != True:
            print('Failed GRU Forward Test: %d / %d' % (i + 1, n))
            return False
        else:
            print('Passed GRU Forward Test: %d / %d' % (i + 1, n))

    # Use to save test data for next semester
    # np.save(os.path.join('autograder', 'hw3_autograder',
    #                      'data', 'gru_forward.npy'), results, allow_pickle=True)

    return True

def gru_cell_backward(forward_vals, dxdh, dws):
    input_dim = 5
    hidden_dim = 2
    seq_len = 10

    # Foward Pass -------------------------->
    data = np.random.randn(seq_len, input_dim)
    hidden = np.random.randn(hidden_dim)

    user_gru_cell = GRU_Cell(input_dim, hidden_dim)
    user_result = user_gru_cell.forward(data[0], hidden)

    if not assertions(user_result, forward_vals, 'type', 'h_t'): return False
    if not assertions(user_result, forward_vals, 'shape', 'h_t'): return False
    if not assertions(user_result, forward_vals, 'closeness', 'h_t'): return False
    # <--------------------------------------

    # Backward pass -------------------------->
    delta = np.random.randn(hidden_dim)
    delta = delta.reshape(1, -1)
    dx, dh = user_gru_cell.backward(delta)
    dx_t, dh_t = dxdh

    if not assertions(dx, dx_t, 'type', 'dx_t'): return False
    if not assertions(dx, dx_t, 'shape', 'dx_t'): return False
    if not assertions(dx, dx_t, 'closeness', 'dx_t'): return False

    if not assertions(dh, dh_t, 'type', 'dh_t'): return False
    if not assertions(dh, dh_t, 'shape', 'dh_t'): return False
    if not assertions(dh, dh_t, 'closeness', 'dh_t'): return False

    dWzh, dWrh, dWh, dWzx, dWrx, dWx = dws

    if not assertions(user_gru_cell.dWzh, dWzh, 'closeness', 'dWzh'): return False
    if not assertions(user_gru_cell.dWrh, dWrh, 'closeness', 'dWrh'): return False
    if not assertions(user_gru_cell.dWzx, dWzx, 'closeness', 'dWzx'): return False
    if not assertions(user_gru_cell.dWrx, dWrx, 'closeness', 'dWrx'): return False
    if not assertions(user_gru_cell.dWh,  dWh, 'closeness', 'dWh'): return False
    if not assertions(user_gru_cell.dWx,  dWx, 'closeness', 'dWx'): return False
    # <--------------------------------------

    return True

def test_gru_backward():
    # Test dWs
    expected_results = np.load(os.path.join('autograder', 'hw3_autograder',
                               'data', 'gru_backward.npy'), allow_pickle=True)

    n = 2
    for i in range(2):
        forward_vals, dxdh, dws = expected_results[i]
        result = gru_cell_backward(forward_vals, dxdh, dws)
        if result != True:
            print('Failed GRU Backward Test: %d / %d' % (i + 1, n))
            return False
        else:
            print('Passed GRU Backward Test: %d / %d' % (i + 1, n))

    # Use to save test data for next semester
    # np.save(os.path.join('autograder', 'hw3_autograder',
    #                      'data', 'gru_backward.npy'), results, allow_pickle=True)

    return True

def generate(mu, sigma, FEATURE_DIM):
    return sigma*np.random.randn(1,FEATURE_DIM) + mu

def create_input_data(SEQUENCE, FEATURE_DIM):
    mean_a = [1.0] * FEATURE_DIM
    mean_b = [5.0] * FEATURE_DIM
    mean_c = [10.0] * FEATURE_DIM

    mean = {'a':mean_a, 'b':mean_b, 'c':mean_c}

    sigma  = 0.2

    inputs = []

    for char in SEQUENCE:
        v = generate(np.array(mean[char]), sigma, FEATURE_DIM)
        inputs.append(v)

    inputs = np.vstack(inputs)
    return inputs

def test_gru_inference():
    ref_outputs = np.load(os.path.join('autograder', 'hw3_autograder',
                               'data', 'gru_inference.npy'), allow_pickle=True)

    FEATURE_DIM = 7
    HIDDEN_DIM = 4
    NUM_CLASSES = 3

    SEQUENCE = 'aaabbbbccc'
    inputs = create_input_data(SEQUENCE, FEATURE_DIM)

    w_ir = np.random.randn(HIDDEN_DIM, FEATURE_DIM)
    w_ii = np.random.randn(HIDDEN_DIM, FEATURE_DIM)
    w_in = np.random.randn(HIDDEN_DIM, FEATURE_DIM)
    w_hr = np.random.randn(HIDDEN_DIM, HIDDEN_DIM)
    w_hi = np.random.randn(HIDDEN_DIM, HIDDEN_DIM)
    w_hn = np.random.randn(HIDDEN_DIM, HIDDEN_DIM)


    # Load weights into student implementation
    student_net = hw3.CharacterPredictor(FEATURE_DIM, HIDDEN_DIM, NUM_CLASSES)
    student_net.init_rnn_weights(w_hi, w_hr, w_hn, w_ii, w_ir, w_in)

    student_outputs = hw3.inference(student_net, inputs)

    if not assertions(student_outputs, ref_outputs, 'type', 'gru inference output'):
        return False
    if not assertions(student_outputs, ref_outputs, 'shape', 'gru inference output'):
        return False
    if not assertions(student_outputs, ref_outputs, 'closeness', 'gru inference output'):
        return False

    # Use to save test data for next semester
    # np.save(os.path.join('autograder', 'hw3_autograder',
    #                      'data', 'gru_inference.npy'), student_outputs, allow_pickle=True)

    return True

############################################################################################
################################   Section 4 - Greedy Search ###############################
############################################################################################

def test_greedy_search():
    y_rands = np.random.uniform(EPS, 1.0, (4,10,1))
    y_sum = np.sum(y_rands, axis=0)
    y_probs = y_rands / y_sum
    SymbolSets = ['a', 'b', 'c']

    expected_results = np.load(os.path.join('autograder', 'hw3_autograder',
                               'data', 'greedy_search.npy'), allow_pickle = True)
    ref_best_path, ref_score = expected_results

    user_best_path, user_score = GreedySearch(SymbolSets, y_probs)

    try:
        assert user_best_path == ref_best_path
    except Exception as e:
        print("Best path does not match")
        print('Your best path:   ', user_best_path)
        print('Expected best path:', ref_best_path)
        return False

    try:
        assert user_score == float(ref_score)
    except Exception as e:
        print("Best Score does not match")
        print('Your score:    ', user_score)
        print('Expected score:', ref_score)
        return False

    # Use to save test data for next semester
    # results = [user_best_path, user_score]
    # np.save(os.path.join('autograder', 'hw3_autograder',
    #                      'data', 'greedy_search.npy'), results, allow_pickle=True)

    return True

############################################################################################
################################   Section 4 - Beam Search ################################
############################################################################################

def test_beam_search_i(y_size, syms, bw, BestPath_ref, MergedPathScores_ref):
    y_rands = np.random.uniform(EPS, 1.0, y_size)
    y_sum = np.sum(y_rands, axis=0)
    y_probs = y_rands/y_sum

    SymbolSets = syms
    BeamWidth = bw

    BestPath, MergedPathScores = BeamSearch(SymbolSets, y_probs, BeamWidth)
    if isTesting:
        try:
            assert BestPath == BestPath_ref
        except Exception as e:
            print("BestPath does not match!")
            print('Your best path:', BestPath)
            print('Expected best path:', BestPath_ref)
            return False

        try:
            assert len(MergedPathScores.keys()) == len(MergedPathScores)
        except Exception as e:
            print("Total number of merged paths returned does not match")
            print('Number of merged path score keys: ', 'len(MergedPathScores.keys()) = ',
                  len(MergedPathScores.keys()))
            print('Number of merged path scores:', 'len(MergedPathScores)= ',
                  len(MergedPathScores))
            return False

        no_path = False
        values_close = True

        for key in MergedPathScores_ref.keys():
            if (key not in MergedPathScores.keys()):
                no_path = True
                print('%s path not found in reference dictionary' % (key))
                return False
            else:
                if not assertions(MergedPathScores_ref[key], MergedPathScores[key],
                                  'closeness', 'beam search'):
                    values_close = False
                    print('score for %s path not close to reference score'%(key))
                    return False
        return True
    else:
        return BestPath, MergedPathScores

def test_beam_search():
    expected_results = np.load(os.path.join('autograder', 'hw3_autograder',
                               'data', 'beam_search.npy'), allow_pickle = True)

    # Initials
    ysizes= [(4,10,1), (5,20,1), (6,20,1)]
    symbol_sets = [['a','b','c'], ['a','b','c','d'], ['a','b','c','d','e']]
    beam_widths = [2, 3, 3]

    n = 3
    results = []
    for i in range(n):
        BestPathRef, MergedPathScoresRef = expected_results[i]
        y_size, syms, bw = ysizes[i], symbol_sets[i], beam_widths[i]
        result = test_beam_search_i(y_size, syms, bw, BestPathRef, MergedPathScoresRef)
        if isTesting:
            if result != True:
                print('Failed Beam Search Test: %d / %d' % (i + 1, n))
                return False
            else:
                print('Passed Beam Search Test: %d / %d' % (i + 1, n))
        else:
            results.append(result)

    # Use to save test data for next semester
    # np.save(os.path.join('autograder', 'hw3_autograder',
    #                      'data', 'beam_search.npy'), results, allow_pickle=True)
    return True



############################################################################################
########################## DO NOT EDIT #########################################
############################################################################################

if __name__ == '__main__':
    # DO NOT EDIT
    print('-'*20)
    print('Section 2 - Multiple Choice Questions')
    a, b, c, d = test_mutiple_choice()
    all_correct = a and b and c and d
    print('Multiple Choice: ', 'PASS' if all_correct else '*** FAIL ***')
    print('-'*20)
    print()

    rnntest = RNN_Test()
    rnn_test_outcome = rnntest.run_test()

    np.random.seed(SEED)

    # DO NOT EDIT
    print('-'*20)
    print('Section 4.1 - GRU Foward')
    gru_forward_outcome = test_gru_forward()

    print('GRU Forward: ', 'PASS' if gru_forward_outcome else '*** FAIL ***')
    print('-'*20)
    print()

    if gru_forward_outcome == False:
        print('*'*77)
        print('The local autograder will not work if you do not pass GRU Foward.')
        print('*'*77)
        print(' ')
        exit(0)

    # DO NOT EDIT
    print('-'*20)
    print('Section 4.2 - GRU Backward')
    gru_backward_outcome = test_gru_backward()
    print('GRU Backward: ', 'PASS' if gru_backward_outcome else '*** FAIL ***')
    print('-'*20)
    print()
    if gru_backward_outcome == False:
        print('*'*77)
        print('The local autograder will not work if you do not pass GRU Backward.')
        print('*'*77)
        print(' ')
        exit(0)

    # DO NOT EDIT
    print('-'*20)
    gru_inference_outcome = test_gru_inference()
    print('Section 4.3 - GRU Inference')
    print('GRU Inference: ', 'PASS' if gru_inference_outcome else '*** FAIL ***')
    print('-'*20)
    print()

    # DO NOT EDIT
    print('-'*20)
    greedy_search_outcome = test_greedy_search()
    print('Section 5.1 - Greedy Search')
    print('Greedy Search: ', 'PASS' if greedy_search_outcome else '*** FAIL ***')
    print('-'*20)
    print()

    # DO NOT EDIT
    print('-'*20)
    print('Section 5.2 - Beam Search')
    beam_search_outcome = test_beam_search()
    print('Beam Search: ', 'PASS' if beam_search_outcome else '*** FAIL ***')
    print('-'*20)
